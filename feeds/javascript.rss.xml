<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>/var/</title><link>http://spapas.github.io/</link><description>Various programming stuff</description><atom:link href="http://spapas.github.io/feeds/javascript.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 27 May 2015 14:20:00 +0300</lastBuildDate><item><title>Using browserify and watchify to improve your client-side-javascriptÂ workflow</title><link>http://spapas.github.io/2015/05/27/using-browserify-watchify/</link><description>&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-problem" id="id1"&gt;The&amp;nbsp;problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-solution" id="id2"&gt;The&amp;nbsp;solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#installing-required-tools" id="id3"&gt;Installing required&amp;nbsp;tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#starting-your-node-js-project" id="id4"&gt;Starting your (node.js)&amp;nbsp;project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#running-browserify-for-the-first-time" id="id5"&gt;Running browserify for the first&amp;nbsp;time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#using-external-libraries" id="id6"&gt;Using external&amp;nbsp;libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#introducing-watchify" id="id7"&gt;Introducing&amp;nbsp;watchify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#creating-your-own-modules" id="id8"&gt;Creating your own&amp;nbsp;modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#uglifying-your-bundle" id="id9"&gt;Uglifying your&amp;nbsp;bundle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#the-client-side-javascript-workflow" id="id10"&gt;The client-side javascript&amp;nbsp;workflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#conlusion" id="id11"&gt;Conlusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="the-problem"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;The&amp;nbsp;problem&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once upon a time, when people started using client-side code to their projects they (mainly
due to the lack of decent client-side libraries but also because of the &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Not_invented_here"&gt;&lt;span class="caps"&gt;NIH&lt;/span&gt; syndrome&lt;/a&gt;)
were just adding their own code in script nodes or .js files using &lt;tt class="docutils literal"&gt;document.getElementById&lt;/tt&gt; to manipulate
the &lt;span class="caps"&gt;DOM&lt;/span&gt; (good luck checking for all possible browser-edge cases)
and &lt;tt class="docutils literal"&gt;window.XMLHttpRequest&lt;/tt&gt; to try doing &lt;span class="caps"&gt;AJAX&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;After these dark-times, the
age of javascript-framework came: prototype, jquery, dojo. These were (and still are)
some great libraries (even &lt;span class="caps"&gt;NIH&lt;/span&gt;-sick people used them to handle browser incompatibilities):
You just downloaded the .js file with the framework, put it inside your project
static files and added it to your page with a script tag and then filled your client-side
code with funny $(&amp;#8216;#id&amp;#8217;)&amp;nbsp;symbols!&lt;/p&gt;
&lt;p&gt;Coming to the modern age in client-side development, the number of decent libraries has greatly increased
and instead of monolithic frameworks there are different libraries for different needs. So instead of
just downloading a single file and adding the script node for that file to your &lt;span class="caps"&gt;HTML&lt;/span&gt;, you need to
download the required javascript files, put them all in your static files directory and then micro-manage
the script nodes for each of your pages depending on which libraries each page needs! So if you want
to use (for example) moment.js to your client-side code you need to go to &lt;em&gt;all&lt;/em&gt; &lt;span class="caps"&gt;HTML&lt;/span&gt; pages that use that
specific client-side code and add a moment.js-script&amp;nbsp;element!&lt;/p&gt;
&lt;p&gt;As can be understood this leads to really ugly situations like people avoiding refactoring their code to use
external libraries, using a single-global module  with all their client side code, using &lt;span class="caps"&gt;CDN&lt;/span&gt; to avoid
downloading the javascript libraries and of course never upgrade their javascript&amp;nbsp;libraries!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-solution"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;The&amp;nbsp;solution&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://browserify.org/"&gt;browserify&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/substack/watchify"&gt;watchify&lt;/a&gt; are two sister tools from the server-side-javascript (node.js and friends)
world that greatly improve your javascript workflow: Using them, you no longer need to micro-manage
your script tags but instead you just declare the libraries each of your client-side modules is
using - or you can even create your own reusable modules! Also, installing (or updating) javascript
libraries is as easy as running a single&amp;nbsp;command!&lt;/p&gt;
&lt;p&gt;How are they working? With browserify you create a single &lt;tt class="docutils literal"&gt;main.js&lt;/tt&gt; for each of your &lt;span class="caps"&gt;HTML&lt;/span&gt;
pages and in it you declare its requirements using &lt;a class="reference external" href="https://github.com/substack/browserify-handbook#require"&gt;require&lt;/a&gt;. You&amp;#8217;ll then pass your &lt;tt class="docutils literal"&gt;main.js&lt;/tt&gt;
through browserify and it will create a single file (e.g &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt;) that contains all the requirements
(of course each requirement could have other requirements - they&amp;#8217;ll be automatically also
included in the resulting .js file). That&amp;#8217;s the &lt;em&gt;only&lt;/em&gt; file you need to put to the script tag of
your &lt;span class="caps"&gt;HTML&lt;/span&gt;! Using watchify, you can &lt;em&gt;watch&lt;/em&gt; your &lt;tt class="docutils literal"&gt;main.js&lt;/tt&gt; for changes (the changes may also
be in the files included from main.js) and automatically generate the resulting &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt; so that
you&amp;#8217;ll just need to hit F5 to refresh and get the new&amp;nbsp;version!&lt;/p&gt;
&lt;p&gt;browserify not only concatenates your javascript libraries to a single bundle but can also transform
your coffesscript, typescript, jsx etc files to javascrpt and &lt;em&gt;then&lt;/em&gt; also add them to the bundle. This
is possible through a concept called transforms &amp;#8212; there are &lt;a class="reference external" href="https://github.com/substack/node-browserify/wiki/list-of-transforms"&gt;a lot of transforms&lt;/a&gt; that you can&amp;nbsp;use.&lt;/p&gt;
&lt;p&gt;Below, I will propose a really simple and generic workflow that should cover most of your javascript needs.
I should mention that I mainly develop django apps and my development machine is running windows, however you
can easily use exactly the  same workflow from any kind of server-side technology (ruby, python, javascript,
java, php or even static &lt;span class="caps"&gt;HTML&lt;/span&gt; pages!) or development machine (windows, linux, osx) - it&amp;#8217;s exactly the&amp;nbsp;same!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="installing-required-tools"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Installing required&amp;nbsp;tools&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As already mentioned, you need two node.js tools. Just install them globally using npm (installing
node.js and npm is really easy - there&amp;#8217;s even &lt;a class="reference external" href="https://nodejs.org/download/"&gt;a package for windows&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
npm install -g browserify watchify
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-g&lt;/span&gt;&lt;/tt&gt; switch installs the packages globally so you can use the browserify and watchify commands from
your command prompt - after that entering &lt;tt class="docutils literal"&gt;browserify&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;watchify&lt;/tt&gt; from your command prompt should be&amp;nbsp;working.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="starting-your-node-js-project"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Starting your (node.js)&amp;nbsp;project&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Although you may already have a project structure, in order to use browserify you&amp;#8217;ll need to
create a node.js project (project from now on) that needs just two&amp;nbsp;things:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; that lists various options for your&amp;nbsp;project&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;node_modules&lt;/tt&gt; directory that contains the packages that your project&amp;nbsp;uses&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To create the &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; you can either copy paste a simple one or run &lt;tt class="docutils literal"&gt;npm init&lt;/tt&gt; inside
a folder of your project. After &lt;tt class="docutils literal"&gt;npm init&lt;/tt&gt; you&amp;#8217;ll need to answer a bunch of questions and then
a &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; will be created to the same folder. If you don&amp;#8217;t want to answer these questions
(most probably you only want to use node.js for browserify - instead you wouldn&amp;#8217;t be reading
this) then just put an empty json string &lt;tt class="docutils literal"&gt;{}&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I recommend adding &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; to the top-level folder of your version-controlled souce-code tree -
please put this file in your version control - the &lt;tt class="docutils literal"&gt;node_modules&lt;/tt&gt; directory will be be created
to the same directory with &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; and should be ignored by your version&amp;nbsp;control.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="running-browserify-for-the-first-time"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Running browserify for the first&amp;nbsp;time&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not the time has come to create a &lt;tt class="docutils literal"&gt;main.js&lt;/tt&gt; file. This could be put anywhere you like (based on your project structure) -
I&amp;#8221; suppose that &lt;tt class="docutils literal"&gt;main.js&lt;/tt&gt; is inside the &lt;tt class="docutils literal"&gt;src/&lt;/tt&gt;  folder of your project.
Just put a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;console.log(&amp;quot;Hello,&lt;/span&gt; world&amp;quot;)&lt;/tt&gt; to the &lt;tt class="docutils literal"&gt;main.js&lt;/tt&gt; for now. To test that everything is working,&amp;nbsp;run:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
browserify src/main.js
&lt;/pre&gt;
&lt;p&gt;You should see some minified-js gibberish to your console (something like &lt;tt class="docutils literal"&gt;(function &lt;span class="pre"&gt;e(t,n,r){function&lt;/span&gt; &lt;span class="pre"&gt;s(o,u){if(!n[o]){if(!t[o]){var&lt;/span&gt; a=typeof &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;
) which means that everything works fine. Now, create a &lt;tt class="docutils literal"&gt;dist&lt;/tt&gt; directory which would contain your bundle files and&amp;nbsp;run&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
browserify src/main.js -o dist/bundle.js
&lt;/pre&gt;
&lt;p&gt;the -o switch will put the the same minified-js gibberish output to the  &lt;tt class="docutils literal"&gt;dist/bundle.js&lt;/tt&gt; file instead of stdout.
Finally, include a script element with that file to your &lt;span class="caps"&gt;HTML&lt;/span&gt; and you
should see &amp;quot;Hello, world&amp;quot; to your javascript console when opening the &lt;span class="caps"&gt;HTML&lt;/span&gt;&amp;nbsp;file!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-external-libraries"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Using external&amp;nbsp;libraries&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To use a library from your main.js you need to install it and get a reference to it through require. Let&amp;#8217;s try to use &lt;a class="reference external" href="http://momentjs.com/"&gt;moment.js&lt;/a&gt;:
To install the library&amp;nbsp;run&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
npm install moment --save
&lt;/pre&gt;
&lt;p&gt;This will create a moment directory inside node_modules that will contain the moment.js library. It will also add a
dependency to your &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; (that&amp;#8217;s what the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--save&lt;/span&gt;&lt;/tt&gt; switch does), something like&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;quot;dependencies&amp;quot;: {
  &amp;quot;moment&amp;quot;: &amp;quot;^2.10.3&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;Whenever you install more client-side libraries they&amp;#8217;ll be saved there. When you want to re-install everything (for instance
when you clone your project) you can just do&amp;nbsp;a&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
npm install
&lt;/pre&gt;
&lt;p&gt;and all dependencies of &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; will be installed in &lt;tt class="docutils literal"&gt;node_modules&lt;/tt&gt; (that&amp;#8217;s why &lt;tt class="docutils literal"&gt;node_modules&lt;/tt&gt; should not be&amp;nbsp;tracked).&lt;/p&gt;
&lt;p&gt;After you&amp;#8217;ve installed moment.js to your project change &lt;tt class="docutils literal"&gt;src/main.js&lt;/tt&gt; to:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
moment = require('moment')
console.log(moment() );
&lt;/pre&gt;
&lt;p&gt;and rerun &lt;tt class="docutils literal"&gt;browserify src/main.js &lt;span class="pre"&gt;-o&lt;/span&gt; dist/bundle.js&lt;/tt&gt;. When you reload your &lt;span class="caps"&gt;HTML&lt;/span&gt; you&amp;#8217;ll see the that you are able to use
moment - all this without changing your &lt;span class="caps"&gt;HTML&lt;/span&gt;!!!&lt;/p&gt;
&lt;p&gt;As you can understand, in order to use a library with browserify, this library must support it by having an npm package. The nice thing is that
most libraries already support it &amp;#8212; let&amp;#8217;s try for another example to use &lt;a class="reference external" href="http://underscorejs.org/"&gt;underscore.js&lt;/a&gt; and (for some reason) we need version underscore 1.7&amp;nbsp;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
npm install underscore&amp;#64;1.7--save
&lt;/pre&gt;
&lt;p&gt;you&amp;#8217;ll se that your package.json dependencies will also contain underscore.js&amp;nbsp;1.7:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
{
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;moment&amp;quot;: &amp;quot;^2.10.3&amp;quot;,
    &amp;quot;underscore&amp;quot;: &amp;quot;^1.7.0&amp;quot;
  }
}
&lt;/pre&gt;
&lt;p&gt;If you want to upgrade underscore to the latest version run&amp;nbsp;a:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
npm install underscore --upgrade --save
&lt;/pre&gt;
&lt;p&gt;and you&amp;#8217;ll see that your &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt; will contan the latest version of&amp;nbsp;underscore.js.&lt;/p&gt;
&lt;p&gt;Finally, let&amp;#8217;s change our &lt;tt class="docutils literal"&gt;src/man.js&lt;/tt&gt; to use&amp;nbsp;underscore:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
moment = require('moment')
_ = require('underscore')

_([1,2,3]).map(function(x) {
  console.log(x+1);
});
&lt;/pre&gt;
&lt;p&gt;After you create your bundle you should se 2 3 4 in your&amp;nbsp;console!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="introducing-watchify"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Introducing&amp;nbsp;watchify&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Running browserify &lt;em&gt;every&lt;/em&gt; time you change your js files to create the &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt; feels
like doing repetitive work - this is where wachify comes to the rescue; watchify is a
tool that watches your source code and dependencies and when a change is detected it will
recreate the bundle&amp;nbsp;automagically!&lt;/p&gt;
&lt;p&gt;To run it, you can&amp;nbsp;use:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
watchify src/main.js -o dist/bundle.js -v
&lt;/pre&gt;
&lt;p&gt;and you&amp;#8217;ll see something like: &lt;tt class="docutils literal"&gt;155544 bytes written to dist/bundle.js (0.57 seconds)&lt;/tt&gt; &amp;#8212; try
changing main.js and you&amp;#8217;ll see that bundle.js will also be&amp;nbsp;re-written!&lt;/p&gt;
&lt;p&gt;Some things to keep in mind with watchify&amp;nbsp;usage:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The -v flag outputs the verbose text (or else you won&amp;#8217;t se any postive messages) - I like using it to be sure that everything is&amp;nbsp;ok.&lt;/li&gt;
&lt;li&gt;You need to use the -o flag with watchify &amp;#8212; you can&amp;#8217;t output to stdout(we&amp;#8217;ll see that this will change our workflow for production a bit&amp;nbsp;later)&lt;/li&gt;
&lt;li&gt;watchify takes the same parameters with browserify &amp;#8212; so if you do any transformations with browserify you can also do them with&amp;nbsp;watchify&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the following, I&amp;#8217;ll assume that you are running the &lt;tt class="docutils literal"&gt;watchify src/main.js &lt;span class="pre"&gt;-o&lt;/span&gt; dist/bundle.js &lt;span class="pre"&gt;-d&lt;/span&gt;&lt;/tt&gt; so your bundles will
always be re-created when changes are&amp;nbsp;found.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-your-own-modules"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Creating your own&amp;nbsp;modules&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Using browserify we can create our own modules and &lt;em&gt;require&lt;/em&gt; them in other modules using the &lt;tt class="docutils literal"&gt;module.exports&lt;/tt&gt; mechanism!&lt;/p&gt;
&lt;p&gt;Creating a module is really simple: In a normal javascript file either assign directly to module.exports or
include all local objects you want to be visible as an attribute to &lt;tt class="docutils literal"&gt;module.exports&lt;/tt&gt; &amp;#8212; everything
else will be private to the&amp;nbsp;module.&lt;/p&gt;
&lt;p&gt;As an example, let&amp;#8217;s create an &lt;tt class="docutils literal"&gt;src/modules&lt;/tt&gt; folder and put a file module1.js inside it, containing the&amp;nbsp;following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
var variable = 'variable'
var variable2 = 'variable2'
var funct = function(x) {
  return x+1;
}
var funct2 = function(x) {
  return x+1;
}

module.exports['variable'] = variable
module.exports['funct'] = funct
&lt;/pre&gt;
&lt;p&gt;As you see, although we&amp;#8217;ve defined a number of things in that module, only the variable and funct attributes
of module.exports will be visible when the module is used. To use the module, change main.js like&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
module1 = require('./modules/module1')
console.log(module1.funct(9))
&lt;/pre&gt;
&lt;p&gt;When you refresh your &lt;span class="caps"&gt;HTML&lt;/span&gt; you&amp;#8217;ll see 10 in the console. So, require will return the &lt;tt class="docutils literal"&gt;module.exports&lt;/tt&gt; objects
of each module. It will either search in your project&amp;#8217;s &lt;tt class="docutils literal"&gt;node_modules&lt;/tt&gt; (when you use just the modfule name,
for example &lt;tt class="docutils literal"&gt;moment&lt;/tt&gt;, or locally (when you start a path with either &lt;tt class="docutils literal"&gt;./&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;../&lt;/tt&gt; &amp;#8212; in our case we required
the module &lt;tt class="docutils literal"&gt;module1.js&lt;/tt&gt; from the folder &lt;tt class="docutils literal"&gt;modules&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;As a final example, we&amp;#8217;ll create another module that is used by module1: Create a file named &lt;tt class="docutils literal"&gt;module2.js&lt;/tt&gt; inside the
&lt;tt class="docutils literal"&gt;modules&lt;/tt&gt; folder and the following&amp;nbsp;contents:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
var funct = function(x) {
    return x+1;
}

module.exports = funct
&lt;/pre&gt;
&lt;p&gt;After that, change &lt;tt class="docutils literal"&gt;module1.js&lt;/tt&gt; to&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
module2 = require('./module2')

var variable = 'variable'
var funct = function(x) {
    return module2(x)+1;
}

module.exports['variable'] = variable
module.exports['funct'] = funct
&lt;/pre&gt;
&lt;p&gt;So &lt;tt class="docutils literal"&gt;module1&lt;/tt&gt; will import the &lt;tt class="docutils literal"&gt;module2&lt;/tt&gt; module (from the same directory) and call it (since a function is assignedd to module.exports).
When you refresh your &lt;span class="caps"&gt;HTML&lt;/span&gt; you should see&amp;nbsp;11!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="uglifying-your-bundle"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;Uglifying your&amp;nbsp;bundle&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If had taken a look at the file size of your &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt; when you&amp;#8217;d included moment.js or underscore.js you&amp;#8217;d see
that the file size has been greatly increased. Take a peek at &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt; and you&amp;#8217;ll see why: The contents of the module files
will be concatenated as they are, without any changes! This may be nice for development / debugging, however for production
we&amp;#8217;d like our bundle.js to be minified &amp;#8212; or uglyfied as it&amp;#8217;s being said in the javascript&amp;nbsp;world.&lt;/p&gt;
&lt;p&gt;To help us with this, uglifying we&amp;#8217;ll use &lt;a class="reference external" href="https://www.npmjs.com/package/uglify-js"&gt;uglify-js&lt;/a&gt;. First of all, please install it&amp;nbsp;globally&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
npm install uglify-js -g
&lt;/pre&gt;
&lt;p&gt;and you&amp;#8217;ll be able to use the &lt;tt class="docutils literal"&gt;uglifyjs&lt;/tt&gt; command to uglify your bundles! To use the &lt;tt class="docutils literal"&gt;uglifyjs&lt;/tt&gt; command for your &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt;
try&amp;nbsp;this&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
uglifyjs dist\bundle.js  &amp;gt; dist\bundle.min.js
&lt;/pre&gt;
&lt;p&gt;and you&amp;#8217;ll see the size of the bundle.min.js greatly reduced! To achieve even better minification (and code mangling as an added
bonus) you could pass the -mc options to&amp;nbsp;uglify:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
uglifyjs dist\bundle.js -mc &amp;gt; dist\bundle.min.js
&lt;/pre&gt;
&lt;p&gt;and you&amp;#8217;ll see an even smaller&amp;nbsp;bundle.min.js!&lt;/p&gt;
&lt;p&gt;As a final step, we can combine the output of browserify and uglify to a single command using a&amp;nbsp;pipe:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
browserify src/main.js | uglifyjs -mc &amp;gt; dist/bundle.js
&lt;/pre&gt;
&lt;p&gt;this will create the uglified bundle.js! Using the pipe to output to uglifyjs is not possible
with watchify since watchify cannot output to stdout &amp;#8212; however, as we&amp;#8217;ll see in the next section
this is not a real&amp;nbsp;problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-client-side-javascript-workflow"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;The client-side javascript&amp;nbsp;workflow&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The proposed client-side javascript workflow uses two commands, one for the development and one
for creating the production&amp;nbsp;bundle.&lt;/p&gt;
&lt;p&gt;For the development, we&amp;#8217;ll use watchify since we need to immediately re-create the bundle when a
javascript source file is changed and we don&amp;#8217;t want any&amp;nbsp;uglification:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
watchify src/main.js -o dist/bundle.js -v
&lt;/pre&gt;
&lt;p&gt;For creating our production bundle, we&amp;#8217;ll use browserify and&amp;nbsp;uglify:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
browserify src/main.js  | uglifyjs -mc warnings=false &amp;gt; dist/bundle.js
&lt;/pre&gt;
&lt;p&gt;(i&amp;#8217;ve added warnings=false to uglfiyjs to suppress&amp;nbsp;warnings).&lt;/p&gt;
&lt;p&gt;The above two commands can either be put to batch files or added to your existing workflow (for example
as &lt;a class="reference external" href="http://www.fabfile.org/"&gt;fabric&lt;/a&gt; commands if you use fabric). However, since we already have a javascrpt project (i.e a &lt;tt class="docutils literal"&gt;package.json&lt;/tt&gt;)
we can use that to run these commands. Just add a &lt;tt class="docutils literal"&gt;scripts&lt;/tt&gt; section to your package.json like&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
{
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;moment&amp;quot;: &amp;quot;^2.10.3&amp;quot;,
    &amp;quot;underscore&amp;quot;: &amp;quot;^1.8.3&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;watch&amp;quot;: &amp;quot;watchify src/main.js -o dist/bundle.js -v&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;browserify src/main.js  | uglifyjs -mc warnings=false &amp;gt; dist/bundle.js&amp;quot;
  }
}
&lt;/pre&gt;
&lt;p&gt;and you&amp;#8217;ll be able to run &lt;tt class="docutils literal"&gt;npm run watch&lt;/tt&gt; to start watchifying for changes and &lt;tt class="docutils literal"&gt;npm run build&lt;/tt&gt; to
create your production&amp;nbsp;bundle!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conlusion"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Conlusion&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the above we saw two (three if we include uglifyjs) javascript tools that will greatly improve our
javascript workflow. Using these we can easily &lt;em&gt;require&lt;/em&gt; (import) external javascript libraries to
our project without any micromanagement of script tags in html files. We also can seperate our own
client-side code to self-contained modules that will only export interfaces and not pollute the global
namespace. The resulting production client-side javascript file will be output minimized and ready to
be used by the users&amp;#8217;&amp;nbsp;browsers.&lt;/p&gt;
&lt;p&gt;All the above are possible with minimal changes to our code and development&amp;nbsp;workflow:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;create a package.json and install your&amp;nbsp;dependencies&lt;/li&gt;
&lt;li&gt;require the external libraries (instead of using them off the global&amp;nbsp;namespace)&lt;/li&gt;
&lt;li&gt;define your module&amp;#8217;s interace through module.exports (instead of polluting the global&amp;nbsp;namespace)&lt;/li&gt;
&lt;li&gt;change your client javascript files to &lt;tt class="docutils literal"&gt;bundle.js&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;npm run watch&lt;/tt&gt; when developing and &lt;tt class="docutils literal"&gt;npm run build&lt;/tt&gt; before&amp;nbsp;deploying&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Serafeim Papastefanos</dc:creator><pubDate>Wed, 27 May 2015 14:20:00 +0300</pubDate><guid>tag:spapas.github.io,2015-05-27:2015/05/27/using-browserify-watchify/</guid><category>javascript</category><category>browserify</category><category>node</category><category>npm</category><category>watchify</category><category>generic</category><category>uglify</category></item></channel></rss>